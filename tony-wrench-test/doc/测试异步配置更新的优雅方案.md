# 测试异步配置更新的优雅方案

## 问题背景

在测试动态配置中心时，需要验证配置变更消息是否能正确更新 Bean 字段。原来的做法是：

```java
@Test
public void test_publish() throws InterruptedException {
    // 推送配置变更消息
    dynamicConfigCenterRedisTopic.publish(new AttributeVO("downgradeSwitch", "4"));
    
    new CountDownLatch(1).await(); // ❌ 阻塞主线程，不够优雅
}
```

**问题**：
- 阻塞主线程，测试永远不会结束
- 不够优雅，不符合测试最佳实践
- 无法验证配置是否真的更新了
- 测试结果不可靠

## 解决方案对比

### 方案一：超时等待（简单有效）

```java
@Test
public void test_publish_with_timeout() throws InterruptedException {
    String initialValue = downgradeSwitch;
    log.info("初始值: {}", initialValue);
    
    // 推送配置变更消息
    dynamicConfigCenterRedisTopic.publish(new AttributeVO("downgradeSwitch", "4"));
    log.info("已发布配置变更消息");
    
    // 等待配置更新（最多等待5秒）
    CountDownLatch latch = new CountDownLatch(1);
    boolean updated = latch.await(5, TimeUnit.SECONDS);
    
    if (updated) {
        log.info("配置已更新: {}", downgradeSwitch);
    } else {
        log.warn("配置更新超时，当前值: {}", downgradeSwitch);
    }
    
    log.info("测试完成，最终值: {}", downgradeSwitch);
}
```

**优点**：
- 简单直接
- 有超时控制
- 不会无限阻塞

**缺点**：
- 仍然使用 CountDownLatch
- 无法真正验证配置更新
- 测试结果不够准确

### 方案二：轮询验证（推荐）

```java
@Test
public void test_publish_with_verification() throws InterruptedException {
    String initialValue = downgradeSwitch;
    log.info("初始值: {}", initialValue);
    
    // 推送配置变更消息
    dynamicConfigCenterRedisTopic.publish(new AttributeVO("downgradeSwitch", "8"));
    log.info("已发布配置变更消息");
    
    // 轮询检查配置是否更新（最多等待10秒）
    int maxAttempts = 20; // 20次 * 500ms = 10秒
    int attempts = 0;
    boolean updated = false;
    
    while (attempts < maxAttempts && !updated) {
        Thread.sleep(500); // 等待500ms
        attempts++;
        
        if (!downgradeSwitch.equals(initialValue)) {
            updated = true;
            log.info("配置已更新，尝试次数: {}, 新值: {}", attempts, downgradeSwitch);
        }
    }
    
    if (!updated) {
        log.warn("配置更新超时，最终值: {}", downgradeSwitch);
    }
}
```

**优点**：
- 真正验证配置更新
- 有超时控制
- 测试结果准确
- 符合测试最佳实践

**缺点**：
- 轮询可能消耗一些资源
- 需要合理设置轮询间隔和次数

### 方案三：测试监听器（最优雅）

```java
@Test
public void test_publish_with_test_listener() throws InterruptedException {
    String initialValue = downgradeSwitch;
    log.info("初始值: {}", initialValue);
    
    // 推送配置变更消息
    dynamicConfigCenterRedisTopic.publish(new AttributeVO("downgradeSwitch", "12"));
    log.info("已发布配置变更消息");
    
    // 使用测试监听器等待配置更新
    String updatedValue = testConfigChangeListener.waitForUpdate("downgradeSwitch", 5, TimeUnit.SECONDS);
    
    if (updatedValue != null) {
        log.info("配置已更新: {} -> {}", initialValue, updatedValue);
    } else {
        log.warn("配置更新超时");
    }
    
    log.info("测试完成，最终值: {}", downgradeSwitch);
}
```

**优点**：
- 最优雅的解决方案
- 基于事件驱动
- 资源消耗最小
- 测试结果最准确
- 支持多个属性同时等待

**缺点**：
- 需要额外的测试监听器组件
- 实现稍微复杂一些

### 方案四：Spring 测试框架特性

```java
@Test
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
public void test_publish_with_spring_test_features() throws InterruptedException {
    String initialValue = downgradeSwitch;
    log.info("初始值: {}", initialValue);
    
    // 推送配置变更消息
    dynamicConfigCenterRedisTopic.publish(new AttributeVO("downgradeSwitch", "16"));
    log.info("已发布配置变更消息");
    
    // 使用Spring的测试等待机制
    Thread.sleep(2000); // 给配置更新一些时间
    
    log.info("测试完成，最终值: {}", downgradeSwitch);
}
```

**优点**：
- 利用 Spring 测试框架特性
- 每次测试都是干净的环境
- 简单易用

**缺点**：
- 使用 Thread.sleep() 不够精确
- 无法验证配置是否真的更新了

## 测试监听器实现

### TestConfigChangeListener 类

```java
@Slf4j
@Component
public class TestConfigChangeListener {

    private final ConcurrentHashMap<String, CompletableFuture<String>> waitingUpdates = new ConcurrentHashMap<>();

    public String waitForUpdate(String attributeName, long timeout, TimeUnit unit) {
        try {
            CompletableFuture<String> future = waitingUpdates.computeIfAbsent(
                attributeName, 
                k -> new CompletableFuture<>()
            );
            
            return future.get(timeout, unit);
        } catch (Exception e) {
            log.warn("等待配置更新超时: {}", attributeName, e);
            return null;
        } finally {
            waitingUpdates.remove(attributeName);
        }
    }

    public void onConfigChange(AttributeVO attributeVO) {
        String attributeName = attributeVO.getAttribute();
        String newValue = attributeVO.getValue();
        
        log.info("测试监听器收到配置变更: {} = {}", attributeName, newValue);
        
        CompletableFuture<String> future = waitingUpdates.get(attributeName);
        if (future != null) {
            future.complete(newValue);
            log.info("已完成配置更新等待: {} = {}", attributeName, newValue);
        }
    }

    public void clear() {
        waitingUpdates.clear();
        log.info("已清理所有等待的配置更新");
    }
}
```

### 集成到动态配置中心

为了让测试监听器能够接收到配置变更消息，需要修改动态配置中心的监听器：

```java
// 在 DynamicConfigCenterAdjustListener 中添加测试监听器支持
@Override
public void onMessage(CharSequence charSequence, AttributeVO attributeVO) {
    try {
        log.info("xfg-wrench dcc config attribute:{} value:{}", 
            attributeVO.getAttribute(), attributeVO.getValue());
        
        // 处理配置变更
        dynamicConfigCenterService.updateAttribute(attributeVO);
        
        // 通知测试监听器（如果存在）
        try {
            ApplicationContext context = ApplicationContextProvider.getApplicationContext();
            TestConfigChangeListener testListener = context.getBean(TestConfigChangeListener.class);
            testListener.onConfigChange(attributeVO);
        } catch (Exception e) {
            // 测试监听器不存在，忽略异常
        }
    } catch (Exception e) {
        log.error("处理配置变更消息失败", e);
    }
}
```

## 最佳实践建议

### 1. 测试方法选择

- **简单测试**：使用方案二（轮询验证）
- **复杂测试**：使用方案三（测试监听器）
- **快速验证**：使用方案四（Spring 测试特性）

### 2. 超时设置

- **开发环境**：5-10秒
- **CI/CD 环境**：10-30秒
- **网络不稳定环境**：30-60秒

### 3. 轮询参数

- **轮询间隔**：200-1000ms
- **最大尝试次数**：根据超时时间计算
- **示例**：10秒超时，500ms间隔 = 20次尝试

### 4. 测试清理

```java
@After
public void tearDown() {
    // 清理测试监听器
    if (testConfigChangeListener != null) {
        testConfigChangeListener.clear();
    }
}
```

### 5. 测试隔离

```java
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
```

确保每个测试方法都有干净的 Spring 上下文。

## 总结

通过以上方案，我们可以优雅地测试异步配置更新：

1. **避免阻塞**：不再使用 `CountDownLatch(1).await()`
2. **准确验证**：真正验证配置是否更新
3. **资源友好**：合理使用系统资源
4. **测试可靠**：测试结果准确可靠
5. **易于维护**：代码清晰，易于理解和维护

推荐使用**方案二（轮询验证）**作为主要方案，**方案三（测试监听器）**作为高级方案。 